<h1>템플릿 syntex</h1>
<h2>Angular 데이터 바인딩</h2>

<p><b>1. 인터폴레이션(Interpolation)</b></p>
<p>표현식을 두개의 중괄호로 열고 닫은 형식을 인터폴레이션이라 한다. 인터폴레이션은 단방향 바인딩에 사용되는 템플릿 문법으로 표현식의 평가 결과를 문자열로 변환하여 템플릭세 바인딩 한다.</p>
<!--<p>형식 : `{{ expression }}`</p>-->
<br>
<p>name: {{ name }}</p>
<p>age: {{ age }}</p>
<p>admin: {{ admin }}</p>
<p>address: {{ address.city }} {{ address.country }}</p>
<p>sayHi(): {{ sayHi() }}</p>
<br>
<br>
<p><b>2. 프로퍼티 바인딩(Property binding)</b></p>
<p>프로퍼티 바인딩은 컴포넌트 클래스의 데이터와 템플릿 간의 단방향 바인딩에 사용되는 템플릿 문법으로 표현식의 평가 결과를 DOM 프로퍼티에 바인딩합니다.</p>
<!--<p>형식 : `<element [property]="expression">...</element>`</p>-->
<!-- value 프로퍼티에 컴포넌트 클래스의 name 프로퍼티 바인딩 -->
<p>value 프로퍼티에 컴포넌트 클래스의 name 프로퍼티 바인딩</p>
<input type="text" [value]="name1">
<p>인터폴레이션을 사용할 경우</p>
<input type="text" value="{{ name1 }}">
<!-- innerHTML 프로퍼티에 컴포넌트 클래스의 contents 프로퍼티 바인딩 -->
<p>innerHTML 프로퍼티에 컴포넌트 클래스의 contents 프로퍼티 바인딩</p>
<p [innerHTML]="contents"></p>
<!-- src 프로퍼티에 컴포넌트 클래스의 imageUrl 프로퍼티 바인딩 -->
<p>src 프로퍼티에 컴포넌트 클래스의 imageUrl 프로퍼티 바인딩</p>
<img [src]="imageUrl"><br>
<!-- disabled 프로퍼티 컴포넌트 클래스의 isUnchanged 프로퍼티 바인딩 -->
<p>disabled 프로퍼티 컴포넌트 클래스의 isUnchanged 프로퍼티 바인딩</p>
<button [disabled]="isDisabled">disabled button</button>
<br>
<br>
<p><b>3. 어트리뷰트 바인딩</b></p>
<p>어트리뷰트 바인딩은 컴포넌트 클래스의 데이터와 템플릿 간의 단방향 바인딩에 사용되는 템플릿 문법으로 표현식의 평가 결과를 HTML 어트리뷰트에 바인딩합니다.</p>
<!--<p>형식 : `<element [attr.attrbute-name]="expression">...</element>`</p>-->
<p>위 프로퍼티 바인딩과 차이점을 이해하기 위해서 HTML 어트리뷰트와 DOM 프로퍼티에 대해서 알아야 합니다.
어트리뷰트와 프로퍼티는 모두 속성으로 번역되어 같은 것으로 오해할 수 있지만 서로 다른 것입니다.
바인딩이 동작하는 방식을 이해하기 위해서는 HTML의 어트리뷰트와 프로퍼티의 차이를 아는 것이 중요합니다.
DOM 프로퍼티는 HTML 요소의 어브리뷰트와는 다릅니다. 브라우저는 HTML 문서를 파싱하여 DOM 트리로 변환하여 메모리에 적재합니다.
이 때 HTML 요소는 DOM 노드 객체로, HTML 어트리뷰트는 DOM 노드 객체의 프로퍼티로 변환됩니다.
HTML 어트리뷰트의 값은 언제나 문자열이지만 DOM 프로퍼티는 객체를 비롯하여 모든 값을 가질 수 있습니다.
어트리뷰트와 프로퍼티가 언제나 1:1로 매핑되는 것이 아니라는 점에 주의해야 합니다. 다음의 예를 참고하세요</p>
<br>
<p>id 어트리뷰트와 id 프로퍼티와 1:1 매핑</p>
<p>class 어트리뷰트는 classList 프로퍼티로 변환</p>
<p>td 요소의 colspan 어트리뷰트의 경우 매핑하는 프로퍼티가 존재하지 않음</p>
<p>textContent 프로퍼티의 경우 어트리뷰트가 존재하지 않음</p>
<p>input 요소의 value 어트리뷰트는 value 프로퍼티와 1:1 매핑하지만 서로 다르게 동작합니다.</p>
<br>
<p>다음의 input 요소는 3개의 어트리뷰트를 가지고 있습니다.
"<input id="user" type="text" value="ungmo2">"
브라우저가 이 코드를 파싱하면 DOM 노드 객체 HTMLInputElement가 생성되고 이 객체는 다양한 프로퍼티를 소유합니다. input 요소의 모든 어트리뷰트는 HTMLInputElement 객체의 attributes 프로퍼티로 변환되고 getAttribute()로 취득 가능합니다.</p>
<br>
<br>
<p><b>4. 클래스 바인딩</b></p>
<p>클래스 바인딩을 사용하면 HTML 클래스 어트리뷰트에 클래스를 추가 또는 삭제할 수 있습니다.</p>
<!--<p>형식 : `<element [class.class-name]="booleanExpression">...</element>`</p>-->
<!--<p>형식 : `<element [class]="class-name-list">...</element>`</p>-->
<p>클래스 바인딩은 우변의 표현식을 편가한 후 HTML 어트리뷰트를 변경합니다. HTML class 어트리뷰트에 의해 이미 클래스가 지정되어 있을 때 한 개의 클래스를 대상으로 하는 클래스 바인딩([class.class-name])은 HTML class 어트리뷰트를
병합(merge)하여 새로운 HTML class 어트리뷰트를 작성합니다. 하지만 복수의 클래스를 대상으로 하는 클래스 바인딩([class])은 기존 HTML class 어트리뷰트를 삭제하고 새로운 HTML class 어트리뷰트를 작성합니다. 사용법은 다음 참고</p>
<!-- 조건에 의한 클래스 바인딩, 우변의 표현식이 true이면 클래스를 추가합니다. -->
<div [class.text-large]="isLarge">text-large</div>
<!-- 조건에 의한 클래스 바인딩 우변의 표현식이 false이면 클래스를 삭제합니다. -->
<div class="text-small color-red" [class.color-red]="isRed">text-small</div>
<!-- 여러 개의 클래스를 한 번에 지정할 수 있습니다. -->
<div [class]="myClasses">text-large color-red</div>
<!-- 클래스 바인딩은 기존 클래스 어트리뷰트보다 우선합니다. 따라서 기존 클래스 어트리뷰트는 클래스 바인딩에 의해 reset됩니다. 클래스 바인딩의 위치는 관계없습니다. -->
<div class="text-small color-blue" [class]="myClasses">text-large color-red</div>
<p>클래스 바인딩은 주로 하나의 클래스를 조건에 의해 추가 또는 삭제하는 용도로 사용합니다. 여러 개의 클래스를 지정할 경우에도 클래스 바인딩을 사용할 수
있으나 ngClass 디렉티브를 사용하면 좀 더 세밀한 제어가 가능합니다.</p>
<br>
<br>
<p><b>5. 스타일 바인딩</b></p>
<p>스타일 바인딩을 사용하면 HTML 요소 스타일 어트리뷰트에 스타일을 지정할 수 있습니다.</p>
<!--<p>형식 : `<element [style.style-property]="expression">...</element>`</p>-->
<p>스타일 바인딩은 우변의 표현식을 평가한 후 HTML style 어트리뷰트를 변경합니다. HTML style 어트리뷰트에 의해 이미 스타일이 지정되어 있을 때
스타일 바인딩은 중복되지 않은 스타일은 병합(merge)하여 그대로 사용하고 중복된 스타일은 스타일 바인딩의 스타일으로 덮어씁니다.
스타일 프로퍼티(border-radius 등)는 케밥표기법(kebab-case) 또는 카멜표기법(camelCase)을 사용합니다. 다음을 참고</p>
<button class="btn" [style.background-color]="isActive ? '#4CAF50' : '#f44336'"
        [style.font-size.em]="isActive ? 1.2 : 1"
        (click)="isActive=!isActive">Toggle</button>
<p>스타일 바인딩은 주로 하나의 인라인 스타일을 조건에 의해 추가하는 용도로 사용합니다. 여러 개의 인라인 스타일을 추가할 경우에는 ngStyle 디렉티브를 사용합니다.</p>
<br>
<br>
<p><b>6. 이벤트 바인딩</b></p>
<p>이벤트 바인딩은 뷰의 상태 변화(버튼 클릭, input에 입력 등)에 의해 이벤트가 발생하면 이벤트 핸들러를 호출하는 것을 말합니다.
지금까지 살펴본 데이터 바인딩은 컨포넌트 클래스에서 템플릿으로 데이터가 이동하였지만 이벤트 바인딩은 템플릿에서 컴포넌트 클래스로 데이터가 이동합니다.</p>
<!--<p>형식 : `<element (event)="statement">...</element>`</p>-->
<p>다음을 참고</p>
<!-- (1) -->
<input type="text" [value]="name2" (input)="onInput($event)">
<!-- (2) -->
<button (click)="onClick()">clear</button>
<!-- (3) -->
<p>name: {{ name2 }}</p>
<p>1. 사용자의 텍스트 입력에 의해 input 이벤트가 발생하면 이벤트 바인딩에 통하여 이벤트 핸들러 onInput을 호출합니다. 이 때 이벤트 정보를 담고 있는
DOM 이벤트 객체 $event를 이벤트 핸들러에 전달할 수 있습니다. 이벤트 핸들러 onInput은 input 이벤트를 발생시킨 input 요소(event.target)의
value 프로퍼티(사용자 입력 텍스트가 담겨 있음)를 $event에서 추출하여 name3 프로퍼티에 할당합니다. name 프로퍼티는 프로퍼티 바인딩에 의해 다시 input 요소에 바인딩 됩니다.</p>
<p>2. 버튼이 클릭되면 click 이벤트가 발생하고 이벤트 바인딩에 의해 이벤트 핸들러 onClick을 호출합니다. onClick은 name3 프로퍼티를 초기화합니다.</p>
<p>3. name3 프로퍼티는 인터폴레이션에 의해 템플릿에 바인딩됩니다.</p>
<p>이벤트 바인딩에는 input이나 click 이벤트 이외에도 다양한 웹 표준 이벤트를 사용할 수 있습니다. 웹 표준 이벤트는 다음을 참고하세요</p>
<a href="https://developer.mozilla.org/en-US/docs/Web/Events">MDN 이벤트 레퍼런스</a>
<br>
<br>
<p><b>7. 양방향 데이터 바인딩</b></p>
<p>양방향 데이터 바인딩은 뷰와 컴포넌트 클래스의 상태 변화를 상호 반영하는 것을 말합니다. 즉 뷰의 상태가 변화하면 컴포넌트 클래스의 상태도 변화하고 그 반대로 컴포넌트 클래스의 상태가 변화하면 뷰의 상태도 변화하는 것입니다.</p>
<!--<p>형식 : `<element [(ngModel)]="property">...</element>`</p>-->
<p>ngModel 디렉티브를 이벤트 바인딩(())과 프로퍼티 바인딩([]) 형식으로 기술한 후 우변에 뷰와 컴포넌트 클래스가 공유할 프로퍼티를 기술합니다. ngModel 디렉티브를 사용하기 위해서는 FormsModule을 모듈에
등록해야 합니다. Angular CLI를 통해 프로젝트를 생성하였다면 FormsModule이 이미 등록되어 있으므로 별도의 등록이 필요없습니다.</p>
<input type="text" [(ngModel)]="name3">
<p>name3: {{ name3 }}</p>
<p>컴포넌트 클래스의 name3 프로퍼티는 템플릿의 input 요소와 양방향으로 바인딩되어 있습니다. 즉 input 요소의 value 프로퍼티가 변화하면 컴포넌트 클래스의 name3 프로퍼티도
동일한 값으로 변화하고 반대로 컴포넌트 클래스의 name3 프로퍼티가 변화하면 input 요소의 value 프로퍼티도 동일한 값으로 변화합니다.</p>
<p>사실 Angular는 양방향 바인딩을 지원하지 않습니다. /[()]-Banana in box라고 함/ 에서 추측할 수 있듯이 양방향 바인딩은 이벤트 바인딩과 프로퍼티 바인딩을 축약표현한 것입니다.
즉 양방향 바인딩은 문법적 편의를 위한 기능이며 실제 동작은 이벤트 바인딩와 프로퍼티 바인딩의 조합으로 이루어집니다. 다음은 이벤트 바인딩과 프로퍼티 바인딩으로 표현한 것입니다.</p>
<input type="text" [value]="name4" (input)="name=$event.target.value">
<p>name: {{ name4 }}</p>
<p>"<input type="text" [(ngModel)]="name">"과 "<input type="text" [value]="name" (input)="name=$event.target.value">"은 정확히 동일하게 동작합니다. ngModel은 이벤트 바인딩과 프로퍼티
  바인딩으로 구현되는 양방향 바인딩을 간편하게 작성할 수 있도록 돕는 디렉티브로서 사용자 입력과 관련돤 DOM 요소(input, textarea, select 등의 form 요소)에서만 사용할 수 있습니다. ngModel을 이벤트 바인딩과 프로퍼티 바인딩으로 표현하여 보겠습니다.</p>
<input [ngModel]="name5" (ngModelChange)="name5=$event">
<p>name5: {{ name5 }}</p>
<p>프로퍼티 바인딩 [ngModel]은 사용자 입력에 관련된 DOM 요소의 프로퍼티(위 예제의 경우 input 요소의 value 프로퍼티)를 업데이트합니다. 그리고 이벤트 바인딩 (ngModelChange)은 이벤트를 수신하고 이벤트 핸들러를 통해
  DOM의 변화를 외부에 알립니다. 이때 ngModelChange는 $event에서 사용자 입력에 관련된 프로퍼티의 값(위 예제의 경우 target.value)를 내부적으로 추출하여 이벤트를 emit합니다.
  양방향 바인딩은 반드시 ngModel 디렉티브를 사용하여야 하는 것은 아니며 커스텀 양방향 데이터 바인딩도 작성할 수 있습니다. 이 방법에 대해서는 컴포넌트 간 데이터 통신을 학습한 이후 설명하도록 합니다.</p>
